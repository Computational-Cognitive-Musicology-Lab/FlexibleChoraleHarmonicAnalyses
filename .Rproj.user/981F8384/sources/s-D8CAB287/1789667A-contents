% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ChoraleAnalysis.R
\name{analyzeChorales}
\alias{analyzeChorales}
\title{Produce harmonic analyses of chorales}
\usage{
analyzeChorales(rank = list(), filter = list(), ...)
}
\arguments{
\item{rank}{A lists of formulae used to rank the harmonic analyses of each contextual window.}

\item{filter}{A lists of formulae used to filter out undesired harmonic interpretations.}

\item{...}{If an optional \code{path} argument is included, the analysis is sent directly to \link{writeHumdrum}, using
the \code{path} (and \code{label} argument if included) from \code{...}.}
}
\description{
This is the master API for the package, which generates specific harmonic
analyses of the 571 chorales. You may specify
one or more criteria for either \emph{filtering} or \emph{ranking} analyses. These criteria
will be used to produced specific harmonic analyses of the 571 chorales, which you may inspect within an R session (\code{\link{viewHumdrum}})
or export to new humdrum data files (\code{\link{writeHumdrum}}).
}
\section{Filtering and Ranking}{
This package contains (internally) precomputed "permutational" analyses of the 571 chorales.
These "permutations" are \emph{every} possible legal harmonic analysis of each of the 24,852 "contextual windows" in the \link[=ChoraleTable_Slices]{chorale dataset}.
Most windows are a single chord or slice and have only one possible analysis (13,466 cases).
However, other windows are more complicated and can have hundreds of possible analyses (1,546 is the maximum!).
Most windows (21,241 out of 24,852) have five or fewer possible analyses.
We can extract our "flexible" output analyses by specifying critetia for filtering and/or ranking the various possible analyses.

Filtering and ranking criteria are specified as R formulae, using the \code{~tilde} operator.
This makes it possible to store, combine, and compose criteria, as R formulae can be held in lists.
Each filter/rank formula is an expression that evaluates within the \code{\link{ChoraleAnalyses}} data object.
\code{\link{ChoraleAnalyses}} contains the parsed features about each individual harmonic analysis of each contextual window, in a tree format.
The top level of the tree divides analysis features into four categories: windows, chords, chord-tones, non-chord tones.
(Read the \link[=ChoraleTable_Slices]{choraleTable} for additional information about the features.)
\itemize{
\item \verb{Window$}: Information about the window itself.
\itemize{
\item \code{Duration} (numeric): duration of windows in tactus units.
\item \code{Number} (integer): enumeration of windows.
\item \code{Slices} (integer): number of slices in
}
\item \verb{Chord$}: Information about the chords in the analysis.
\itemize{
\item \verb{CompletionDelay$} (list of two):
\itemize{
\item In some cases all the notes of a harmony don't appear at the same time, yet we recognize the chord to have arrived.
The complettion delay indicates how long it takes for the "complete" chord to be sounded after the chord arrives.
\item \code{Durations} (list of numeric):
\itemize{
\item Completion delay in tactus units.
}
\item \code{Slices} (list of integer):
\itemize{
\item Completion delay in number of slices.
}
}
\item \code{Count} (integer): How many chords in the window?
\item \code{Durations} (list of numeric): The duration of the chord(s) in tactus units.
\item \code{Inversion} (list of integer): The inversion of the chord:
\itemize{
\item \code{0}: root position
\item \code{1}: first inversion
\item \code{2}: second inversio
\item \code{3}: third inversion.
}
\item \code{Qualities} (list of character):
The quality of the chord(s):
\itemize{
\item \code{"M"} (major)
\item \code{"m"} (minor)
\item \code{"d"} (diminished)
\item \code{"MM"} (major 7th)
\item \code{"Mm"} (dominant 7th)
\item \code{"mm"} (minor 7th)
\item \code{"dm"} (half-diminished 7th)
\item \code{"dd"} (fully-diminished 7th)
}

Incomplete triads are indicated:
\itemize{
\item \code{"m(?5)"}: a minor third with missing 5th.
\item \code{"M(?5)"}: a major third with missing 5th.
\item \code{"P5"}: perfect 5th with no 3rd.
}

Incomplete seventh chords are indicated:
\itemize{
\item \code{"(MM)"}: Apparent \code{"MM"} but missing 5th; i.e., major 3rd and major 7th are present.
\item \code{"(mm)"}: minor 3rd and minor 7th but missing 5th. Could be \code{"mm"} or \code{"dm"}.
\item \code{"(Mm)"}: major 3rd and minor 7th but missing 5th. Only makes sense as incomplete \code{"Mm"}.
\item \code{"(dm)"}: dimished 5th and minor 7th but missing 3rd. Only makes sense as incomplete \code{"dm"}.
\item \code{"(dd)"}: dimished 5th and diminished 7th but missing 3rd. Only makes sense as incomplete \code{"dm"}.
\item \code{"(?m)"}: perfect 5th and minor 7th but missing 3rd. Could be \code{"Mm"} or \code{"mm"}.
\item \code{"(??)"}: minor 7th but no fifth \emph{or} third.
}
\item \code{Roots} (list of character): The root of the chord(s): combinations of the letters A-G with zero or more sharps (\verb{#}) or flats (\code{-}).
For example, \code{"G"}, \code{"A-"}, or \code{"F##"}.
\item \code{SeventhsResolve} (list of logical): A logical (TRUE/FALSE) indicating if 7ths in the chord resolve downward by step (eventually).
If there is no 7th in the chord, value is \code{NA}.
\item \code{Slices} (list of integer): How many slices per chord?
}
\item \verb{CTs$} (chord tones)
\itemize{
\item \code{Contour} (data.table; 11 columns of integers):
How many of each contour type are counted as chord tones, each column being one type.
See the \link[=ChoraleTable_Slices]{chorale table} documentation for a list of the types.
\item \code{Count} (integer):
\itemize{
\item How many chord tones are their in the window?
}
\item \code{Duration} (list):
\itemize{
\item Duration (in tactus units) of the chord-tones in the analysis.
}
}
\item \verb{NCTs$} (non-chord tones)
\itemize{
\item \code{Contour} (data.table; 11 columns of integers):
How many of each contour type are counted as non-chord tones, each column being one type.
See the \link[=ChoraleTable_Slices]{chorale table} documentation for a list of the types.
\item \code{Count} (integer):
\itemize{
\item How many non-chord tones are their in the window?
}
\item \code{Duration} (list):
\itemize{
\item Duration (in tactus units) of the chord-tones in the analysis.
}
}
}

A filtering/ranking formulae must refer to fields in the \code{ChoraleAnalyses} tree.
Levels in the tree can be stepped through using the R \code{$} operator.
For example, we can refer to \code{NCTs$Contour$PT} to get the count of non-chord tone passing tones in analyses
\subsection{"Lists of"}{
}

\subsection{Creating Filters/Rankings}{

You can compose any R expression you want using fields of the \code{ChoraleAnalyses} tree!
Filtering formulae must return logical (TRUE or FALSE) values: only harmonic analyses for which the filter(s) return TRUE are used.
Ranking formulae can return any numeric values: harmonic analysis are ranked from best to worst (high to low rank) according the the ranking formulae,
and the highest rank analyses are used.
When analyses are tied in rank, you'll just get a more or less random pick from the ties---the sollution is to be more specific in your ranking/filtering!
Logical values in a ranking formulae are treated as numeric 0 (FALSE) and 1 (TRUE).

Watch out!
Overly zealous filters can easily lead to some harmonic slices with no legal analysis, which are then marked "X" in the output.
Prefer using ranking formulae over filters to avoid this problem---ranking formulae will always return something.

If you find this all confusing, that is understandable! Some examples should help:
\subsection{More Chords}{

Lets say prefer analyses that use as many chords as possible.
You could just use a ranking formulae of \code{rank = ~Chords$Count}.
This formula will return the value of \code{ChoraleAnalyses$Chords$Count}, which are integers indicating how many chords there are in the window.
These numbers will be used to rank the analysis, with higher numbers being better---the result will be analyses with as many chords as possible.
If you want to be more specific you could add a ranking criteria, minimizing the number of non-chord tones: \code{rank = c(~Chords$Count, ~ NCTs$Count * -1)}.
This will return the number of chords \emph{and} the negative number of non-chord tones---the maximium rank will be the analysis with the most chords and the least non-chord tones.
}

\subsection{Fewer chords}{

Lets say you instead want to minimize the number of chords, getting a more abstract, "high-level" analysis.
You can more or less reverse the formulae in the last example: \code{rank = ~ Chords$Count * -1}, or \code{rank = c(~ Chords$Count * -1, ~ NCTs$Count)}.
}

\subsection{Lists of X}{

You'll note that many fields of the \code{ChoraleAnalyses} tree are "lists of" vectors.
These are vectors of varying lengths corresponding to the number of chords in each analysis.
If, for a particular analysis, \code{Chord$Count} has a value if \code{3} that means the window is being analyzed with three chords.
Thus, \code{Chord$Root} will be a vector of length three representing the roots of the three chords, in order.
Similarly, \code{Chord$SeventhsResolve} will be a vector of length three indicating if 7ths in each of the three chords resolve or not (\code{NA} if there is no 7th).

The package performs some extra magic to help us work with these lists of vectors.
If you wrap your expressions in calls to \code{any}, \code{all}, \code{max}, \code{min}, \code{mean}, or \code{sum} in your formulae, immediately after the \code{~},
they will automatically apply to the nested values.
For example, if you say \code{rank = ~ any(Chord$SeventhsResolve)}, the analyses will be ranked to prefer analyses where are least one of the 7ths in the chords (if any) resolve.
Similarly,  \code{rank = ~ all(Chord$SeventhsResolve)} will prefer analyses where \emph{all} 7ths resolve.
For a finer grain ranking: \code{rank = ~ mean(Chord$SeventhsResolve)} will return the average of the logicals treated as \code{0}s and \code{1}s, so you get the proportion of chords sevenths which resolve.

Another example would be to use \code{rank = ~ min(Chord$Duration) >= 1}, will prefer analyses where the minimum chord duration is a tactus or greater.

If more than one list fields are included in the nested call (to \code{any}, \code{all}, etc.), they will all be mapped across in parallel.
Non nested fields will also be mapped across.
}

\subsection{ranks function}{

Another useful function is the \link{ranks} function.
The \link{ranks} function is most useful for ranking \code{Chord$Qualities}.
}

}

\subsection{Standard Analyses}{

You will find that there are a few ranking criteria that you almost always want to use to get reasonable analyses.
These include various combinations of:
\itemize{
\item \code{~ mean(Chord$SeventhsResolve)}: more sevenths resolving is good!
\item \verb{~ ranks(Qualities, 'M|m'=4, 'd|Mm'=3, 'mm|MM' = 2, 'dm|dd'=1))}: prefer simpler chords
}
}
}

\section{Write Output}{
If you want to directly output your analyses to humdrum files, add a \code{path} (and optional \code{label}) argument to your call.
This will pass the analysis and the \code{path}/\code{label} arguments directly to \link{writeHumdrum}.
}

\examples{

analysis1 <- analyzeChorales(list(~ Chord$Count))
analysis2 <- analyzeChorales(filter = list(~ Chord$Count))

viewHumdrum('Bach', 10, analysis1)
writeHumdrum(analyses, label = 'analysis1')

###

analyses <- c(analysis1, analysis2)
viewHumdrum('Bach', 10, analyses)

writeHumdrum(analyses, label = 'twoAnalyses')

}
