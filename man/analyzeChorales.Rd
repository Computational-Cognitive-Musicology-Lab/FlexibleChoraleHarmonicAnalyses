% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ChoraleAnalysis.R, R/ChoraleData.R
\docType{data}
\name{analyzeChorales}
\alias{analyzeChorales}
\alias{ChoraleAnalyses}
\title{Produce harmonic analyses of chorales}
\format{
An object of class \code{list} of length 4.
}
\usage{
analyzeChorales(rank = list(), filter = list(), ...)

ChoraleAnalyses
}
\arguments{
\item{rank}{A single formula or a list of formulae used to rank the harmonic analyses of each contextual window.}

\item{filter}{A  single formula or a list of formulae used to filter out undesired harmonic interpretations.}

\item{...}{If an optional \code{path} argument is included, the analysis is sent directly to \link{writeHumdrum}, using
the \code{path} (and \code{label} argument if included) from \code{...}.}
}
\description{
This is the master API for the package, which generates specific harmonic
analyses of the 571 chorales. You may specify
one or more criteria for either \emph{filtering} or \emph{ranking} analyses. These criteria
will be used to produced specific harmonic analyses of the 571 chorales, which you may inspect within an R session (\code{\link{viewHumdrum}})
or export to new humdrum data files (\code{\link{writeHumdrum}}).
}
\section{Filtering and Ranking}{
This package contains (internally) precomputed "permutational" analyses of the 571 chorales.
These "permutations" are \emph{every} possible legal harmonic analysis of each of the 24,852 "contextual windows" in the \link[=ChoraleTable_Slices]{chorale dataset}.
Most windows are a single chord or slice and have only one possible analysis (13,466 cases).
However, other windows are more complicated and can have hundreds of possible analyses (1,546 is the maximum!).
Most windows (21,241 out of 24,852) have five or fewer possible analyses.
We can extract our "flexible" output analyses by specifying criteria for filtering and/or ranking the various possible analyses.

Filtering and ranking criteria are specified as R formulae, using the \code{~} (tilde) operator.
Each formula must be expression that evaluates using the fields of the (hidden) ChoraleAnalyses data object.
\verb{ChoraleAnalyses`` contains parsed features about each of the individual harmonic *analysis* of each contextual window in a (shallow) tree format. You will specify criteria for harmonic analyses by referring to the fields in the}ChoraleAnalyses\verb{tree; thus, getting to know the fields/features of the}ChoraleAnalyses` tree is essential to making use of the package.

\code{ChoraleAnalyses} is a nested \code{list}, so R's \code{$} operator can be used to step through levels in the tree:
Note that some of the field names in the table below end with \code{$}---these are non-terminal branches of the tree.
Terminal branches (actual features you can use for filtering/ranking) are followed by a parenthetical indicating their data type.
The top level of the tree divides analysis features into four categories: windows, chords, chord-tones, non-chord tones.
The full tree's fields (and their respective data types) are:
\itemize{
\item \verb{Window$}: Information about the window itself.
\itemize{
\item \code{Duration} (numeric): duration of window in tactus units.
\item \code{Number} (integer): enumeration of window.
\item \code{Slices} (integer): number of slices in the window.
}
\item \verb{Chord$}: Information about the chords in the analysis.
\itemize{
\item \verb{CompletionDelay$} (list of two):
\itemize{
\item In some cases all the notes of a harmony don't appear at the same time, yet we recognize the chord to have "arrived."
The completion delay indicates how long it takes for the "complete" chord to be sounded after the chord arrives.
\item \code{Durations} (list of numeric):
\itemize{
\item Completion delay in tactus units.
}
\item \code{Slices} (list of integer):
\itemize{
\item Completion delay in number of slices.
}
}
\item \code{Count} (integer): How many chords in the window?
\item \code{Durations} (list of numeric): The duration of the chord(s) in tactus units.
\item \code{Inversions} (list of integer): The inversion of the chord:
\itemize{
\item \code{0}: root position
\item \code{1}: first inversion
\item \code{2}: second inversion
\item \code{3}: third inversion.
}
\item \code{Qualities} (list of character):
The quality of the chord(s).
Complete triads and 7th chords are indicated:
\itemize{
\item \code{"M"} (major)
\item \code{"m"} (minor)
\item \code{"d"} (diminished)
\item \code{"MM"} (major 7th)
\item \code{"Mm"} (dominant 7th)
\item \code{"mm"} (minor 7th)
\item \code{"dm"} (half-diminished 7th)
\item \code{"dd"} (fully-diminished 7th)
}

Incomplete triads are indicated:
\itemize{
\item \code{"m(?5)"}: a minor third with missing 5th.
\item \code{"M(?5)"}: a major third with missing 5th.
\item \code{"P5"}: perfect 5th with no 3rd.
}

Incomplete seventh chords are indicated:
\itemize{
\item \code{"(MM)"}: Apparent \code{"MM"} but missing 5th; i.e., major 3rd and major 7th are present.
\item \code{"(mm)"}: minor 3rd and minor 7th but missing 5th. Could be \code{"mm"} or \code{"dm"}.
\item \code{"(Mm)"}: major 3rd and minor 7th but missing 5th. Only makes sense as incomplete \code{"Mm"}.
\item \code{"(dm)"}: diminished 5th and minor 7th but missing 3rd. Only makes sense as incomplete \code{"dm"}.
\item \code{"(dd)"}: diminished 5th and diminished 7th but missing 3rd. Only makes sense as incomplete \code{"dd"}.
\item \code{"(?m)"}: perfect 5th and minor 7th but missing 3rd. Could be \code{"Mm"} or \code{"mm"}.
\item \code{"(??)"}: minor 7th but no fifth \emph{or} third.
}
\item \code{Roots} (list of character): The root of the chord(s): combinations of the letters A-G with zero or more sharps (\verb{#}) or flats (\code{-}).
For example, \code{"G"}, \code{"A-"}, or \code{"F##"}.
\item \code{SeventhResolves} (list of logical): A logical (TRUE/FALSE) indicating if 7ths in the chord resolve downward by step (eventually).
If there is no 7th in the chord, value is \code{NA}.
\item \code{Slices} (list of integer): How many slices per chord?
}
\item \verb{CTs$} (chord tones)
\itemize{
\item \code{Contour} (data.table; 11 columns of integers):
How many of each contour type are counted as chord tones, each column being one type.
See the \link[=ChoraleTable_Slices]{chorale table} documentation for a list of the types.
\item \code{Count} (integer):
\itemize{
\item How many chord tones are there in the window?
}
\item \code{Durations} (list):
\itemize{
\item Duration (in tactus units) of the chord-tones in the analysis. Ordered by voice (soprano to bass), then by slice.
}
}
\item \verb{NCTs$} (non-chord tones)
\itemize{
\item \code{Contour} (data.table; 11 columns of integers):
How many of each contour type are counted as non-chord tones, each column being one type.
See the \link[=ChoraleTable_Slices]{chorale table} documentation for a list of the types.
\item \code{Count} (integer):
\itemize{
\item How many non-chord tones are there in the window?
}
\item \code{Durations} (list):
\itemize{
\item Duration (in tactus units) of the chord-tones in the analysis. Ordered by voice (soprano to bass), then by slice.
}
}
}

(Read the \link[=ChoraleTable_Slices]{choraleTable} documentation for additional information about the features.)

To illustrate how this works, we can refer to \code{~ NCTs$Contour$PT} to get the field containing the count of non-chord-passing-tones in each analysis.
Similarly, we can access the field indicating the inversion of chords using \code{~Chord$Inversion}.
As a shorthand, you can place some of the tree nodes (including \code{$}s) on the left-hand side of a formula's \code{~}:
Variables on the right-hand side are then evaluated within the left-hand node.
For example, we write \code{NCTs$Contour ~ PT} instead of \code{~ NCTs$Contour$PT}.
This is most useful when referring to multiple fields within one branch of the tree: for example, \code{NCTs$Contour ~ PT > NT}
is a legal way of using \emph{both} the \code{NCTs$Contour$PT} and \code{NCTs$Contour$NT} fields.
\subsection{Creating Filters/Rankings}{

You can compose any R expression you want using fields of the \code{ChoraleAnalyses} tree!
This can include arithmetic, comparison operators (\code{>}, \code{<}, etc.), or even your own arbitrary functions.
Since you have the entire \code{ChoraleAnalyses} feature tree (above) at your finger tips, you can make a huge variety of
possible criteria for selecting the harmonic analyses you prefer.
For example, \code{NCTs$Contour ~ PT > NT} accesses the \code{NCTs$Contour$PT} and \code{NCTs$Contour$NT} and asks which analyses
have more non-chord-passing tones than non-chord-neighboring tones (using \code{>}).
Used as a rank or filter, this formula would favor analyses where there are more passing tone NCTs than neighboring tone NCTs.

Filtering formulae must return logical (\code{TRUE} or \code{FALSE}) values: only harmonic analyses for which the filter(s) return \code{TRUE} are used.
Ranking formulae, on the other hand, can return any numeric values: harmonic analysis are ranked from best to worst (high to low rank)
according the results of your ranking formulae
and the highest rank analysis for each window is used in the output analyses.
When analyses are tied in rank you'll just get a more or less random pick from the ties---the solution is to be more specific
in your ranking/filtering!
Logical values in a ranking formulae are treated as numeric 0 (FALSE) and 1 (TRUE).

Watch out!
Overly zealous filters can easily lead to some harmonic slices with no legal analysis, which are then marked "X" in the output.
Prefer using ranking formulae over filters to avoid this problem---ranking formulae will always return something.

Having ranking/filtering criteria expressed as R formulae makes it possible to store, combine, and compose criteria,
as R formulae can be held in lists.
You can concatenate formulae using \code{c(...)}.
For example, if you have ranking formula that you use a lot you could assign it to a variable, like \code{ccount = Count ~ Chord}.
You can then mix \code{ccount} with other formula by concatenating them: \verb{c(ccount, ~ another criteria, ~ a third criteria, etc)}.
You may want to try out various combinations of 4--6 different ranking criteria.

If you find this all confusing, that is understandable! Some examples should help:
\subsection{More Chords}{

Lets say you prefer analyses that use as many chords as possible (generally minimizing non-chord tones).
You could just use a ranking formulae of \code{rank = Chord ~ Count}.
This formula will return the value of \code{ChoraleAnalyses$Chord$Count}, which are integers indicating how many chords there are in the window.
These numbers will be used to rank the analysis, with higher numbers being better---the result will be analyses with as many chords as possible.
If you want to be more specific you could add another ranking criteria, minimizing the number of non-chord tones:
\code{rank = c(Chord ~ Count, NCTs ~ Count * -1)}.
This will return the number of chords \emph{and} the negative number of non-chord tones---the maximum
rank will be the analysis with the most chords \emph{and} the least non-chord tones.
}

\subsection{Fewer chords}{

Lets say you instead want to \emph{minimize} the number of chords, getting a more abstract, "high-level" analysis.
You can just reverse the formulae in the last example: \code{rank = Chord ~ Count * -1}, or \code{rank = c(Chord ~ Count * -1, NCTs ~ Count)}.
}

}

\subsection{Lists of X}{

You'll note that many fields of the \code{ChoraleAnalyses} tree are "lists of" vectors.
These are vectors of varying lengths corresponding to the number of chords in each analysis.
If, for a particular analysis, \code{Chord$Count} has a value if \code{3} that means the window is being analyzed with three chords.
Thus, \code{Chord$Roots} will be a vector of length three, representing the roots of the three chords in order.
Similarly, \code{Chord$SeventhResolves} will be a vector of length three indicating if 7ths in each of the three chords resolve or not (\code{NA} if there is no 7th).
All of these fields have plural names, so be careful: Its \code{Chord$Durations} not \code{Chord$Duration}.

The package performs some extra magic to help us work with these lists of vectors.
If you use calls to \code{any}, \code{all}, \code{max}, \code{min}, \code{mean}, or \code{sum} in your filter/rank formulae
they will automatically apply to the nested values.
For example, if you say \code{rank = Chord ~ any(SeventhResolves)}, the analyses will be ranked to prefer analyses where are at least one (i.e., any) of
the 7ths in the chords (if any) resolve.
Similarly,  \code{rank = Chord ~ all(SeventhResolves)} will prefer analyses where \emph{all} 7ths resolve.
For a finer-grain ranking: \code{rank = Chord ~ mean(SeventhResolves)} will return the average of the logicals treated as \code{0}s and \code{1}s, so you get
the proportion of chords sevenths which resolve---more resolving sevenths the better.

Another example would be to use \code{rank = ~ Chord ~ min(Durations) >= 1}, which
will prefer analyses where the minimum chord duration is a tactus or greater.

If more than one list fields are included in the nested call (to \code{any}, \code{all}, etc.), they will all be mapped across in parallel.
Non-nested fields will also be mapped across as well.
(Note that all these special nested calls are called with the \code{na.rm = TRUE}.)
\subsection{Ranking}{

Another useful function is the \link{\%ranks\%} function.
The \link{\%ranks\%} function is most useful for ranking \code{Chord$Qualities}.
You can also use the standard R \link[=cut]{base} function to cut
numeric values into ranked categories (set \code{ordered_result = TRUE}).
}

}
}

\section{Standard Analyses}{
You will find that there are a few ranking criteria that you almost always want to use to get reasonable analyses.
These include various combinations of:
\itemize{
\item \code{Chord ~ mean(SeventhResolves)}: more sevenths resolving is good!
\item \code{Chord ~ min(Qualities \%ranks\% c('M|m|d|Mm'=4, 'MM|mm|dm|dd' = 2, 0))}: prefer analyses without any
rarer chords.
\item \code{NCTs ~ -1 * max(Durations)}: having long-duration non-chord tones is a little weird, so prefer shorter ones.
You might alternatively use \code{mean(Duration)}.
\item \code{Chord ~ abs(mean(Durations) - 1)}: favor analyses where chord durations average close to 1 (the tactus).
\item \code{Chord$CompletionDelay ~ max(Durations) * -1}: prefer analyses with short completion delay...i.e., transition directly to complete chords.
}
}

\section{Write Output}{
If you want to directly output your analyses to humdrum files, add a \code{path} (and optional \code{label}) argument to your call.
This will pass the analysis and the \code{path}/\code{label} arguments directly to \link{writeHumdrum}.
}

\examples{

analysis1 <- analyzeChorales(Chord ~ Count)


viewHumdrum('bach', 10, analysis1)
writeHumdrum(analysis1, label = 'analysis1')

###

shortNCTs    <- NCTs ~ -max(Durations)
triads       <- Chord ~ min(Qualities \%ranks\% c('M|m|d|Mm'=4, 'MM|mm|dm|dd' = 2, 0))
resolved7ths <- Chord ~ mean(SeventhResolves)

analysis2 <- analyzeChorales(c(shortNCTs, triads, resolved7ths, Chord$CompletionDelay ~ max(Durations) * -1 ))

###

analyses <- c(analysis1, analysis2)
viewHumdrum('bach', 10, analyses)

writeHumdrum(analyses, label = 'twoAnalyses')

}
\keyword{datasets}
